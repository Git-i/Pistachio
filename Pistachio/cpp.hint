// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define PROPERTY(Class, parent_class, value_name, getter, setter) struct TOKENPASTE2(Property, __LINE__)__##Class{private: Class this_value; Class get() getter; void set(const Class& value) { parent_class* parent = EmbeddorOf(parent_class, value_name); Class& old_value = this->this_value; setter};public: TOKENPASTE2(Property, __LINE__)__##Class(const Class& obj) {set(obj);} template<typename T, typename _ = typename std::enable_if<(sizeof(std::declval<Class&>() += std::declval<T>()) > 2)>::type> auto operator+=(T a) { auto _temp = get(); set(_temp += a); }; template<typename T, typename _ = typename std::enable_if<(sizeof(std::declval<Class&>() -= std::declval<T>()) > 2)>::type> auto operator-=(T a) { auto _temp = get(); set(_temp -= a); }; template<typename T, typename _ = typename std::enable_if<(sizeof(std::declval<Class&>() *= std::declval<T>()) > 2)>::type> auto operator*=(T a) { auto _temp = get(); set(_temp *= a); }; template<typename T, typename _ = typename std::enable_if<(sizeof(std::declval<Class&>() /= std::declval<T>()) > 2)>::type> auto operator/=(T a) { auto _temp = get(); set(_temp /= a); }; template<typename T, typename _ = typename std::enable_if<(sizeof(std::declval<Class&>() %= std::declval<T>()) > 2)>::type> auto operator%=(T a) { auto _temp = get(); set(_temp %= a); }; template<typename T, typename _ = typename std::enable_if<(sizeof(std::declval<Class&>() &= std::declval<T>()) > 2)>::type> auto operator&=(T a) { auto _temp = get(); set(_temp &= a); }; template<typename T, typename _ = typename std::enable_if<(sizeof(std::declval<Class&>() |= std::declval<T>()) > 2)>::type> auto operator|=(T a) { auto _temp = get(); set(_temp |= a); }; template<typename T, typename _ = typename std::enable_if<(sizeof(std::declval<Class&>() ^= std::declval<T>()) > 2)>::type> auto operator^=(T a) { auto _temp = get(); set(_temp ^= a); }; template<typename T, typename _ = typename std::enable_if<(sizeof(std::declval<Class&>() += std::declval<T>()) > 2)>::type> auto operator<<=(T a) { auto _temp = get(); set(_temp <<= a); }; template<typename T, typename _ = typename std::enable_if<(sizeof(std::declval<Class&>() += std::declval<T>()) > 2)>::type> auto operator>>=(T a) { auto _temp = get(); set(_temp >>= a); }; void operator=(Class a) { set(a); }; operator Class() { return get(); }} value_name
